# Test Cleanup Implementation

## Overview
This document describes the comprehensive test cleanup system implemented for Docker MCP tests. The system ensures that all test resources (containers, stacks, etc.) are properly cleaned up after tests run, even when tests fail or are interrupted.

## Components

### 1. cleanup_utils.py
Core utilities for tracking and cleaning test resources:

- **TestResourceTracker**: Central class for tracking deployed resources
- **cleanup_test_containers()**: Clean up containers by pattern
- **cleanup_test_stacks()**: Clean up stacks by pattern
- **verify_cleanup()**: Verify resources were removed
- **emergency_cleanup()**: Nuclear option to clean all test resources
- **@with_cleanup decorator**: Automatic cleanup for test methods

### 2. cleanup.py
Manual cleanup script for operations and maintenance:

```bash
# Clean up all test resources on all hosts
python tests/cleanup.py

# Clean up specific host
python tests/cleanup.py --host squirts

# Dry run (show what would be cleaned)
python tests/cleanup.py --dry-run

# Clean up specific pattern
python tests/cleanup.py --pattern "test-mcp"

# Emergency cleanup (remove ALL test resources)
python tests/cleanup.py --emergency

# Clean up known orphaned resources
python tests/cleanup.py --known-orphans
```

### 3. Enhanced conftest.py Fixtures

#### test_nginx_container Fixture
- Uses `request.addfinalizer()` for guaranteed cleanup
- Tracks resources with TestResourceTracker
- Records cleanup failures for reporting
- Cleanup runs even if test fails

#### Session-Level Cleanup Fixture
- `scope="session"` and `autouse=True`
- Runs after ALL tests complete
- Performs emergency cleanup on remaining resources
- Generates cleanup report

## Cleanup Patterns

### 1. Try-Finally Blocks
```python
async def test_deploy_stack(self, client, test_host_id):
    tracker = get_resource_tracker()
    stack_name = "test-stack"
    
    try:
        # Deploy stack
        result = await client.call_tool("deploy_stack", {...})
        tracker.add_stack(test_host_id, stack_name)
        # Test assertions
        
    finally:
        # Cleanup always runs
        try:
            await client.call_tool("manage_stack", {
                "host_id": test_host_id,
                "stack_name": stack_name,
                "action": "down"
            })
            tracker.remove_stack(test_host_id, stack_name)
        except Exception as e:
            tracker.record_failure("stack", stack_name, test_host_id, str(e))
```

### 2. Pytest Finalizers
```python
@pytest.fixture
async def deployed_stack(client, test_host_id, request):
    stack_name = "test-stack"
    
    async def cleanup():
        # Cleanup logic
        pass
    
    # Register finalizer - runs even if fixture setup fails
    request.addfinalizer(lambda: asyncio.run(cleanup()))
    
    # Deploy resource
    yield stack_name
```

### 3. Decorator Pattern
```python
@with_cleanup("squirts")
async def test_something(self, client):
    # Test code - cleanup handled automatically
    pass
```

## Resource Tracking

The TestResourceTracker maintains:
- Dictionary of containers by host
- Dictionary of stacks by host
- List of failed cleanup attempts
- Cleanup report generation

## Cleanup Execution Order

1. **Test-level cleanup**: Try-finally blocks in test methods
2. **Fixture cleanup**: Pytest finalizers in fixtures
3. **Decorator cleanup**: @with_cleanup decorator
4. **Session cleanup**: Session-level fixture (autouse)
5. **Manual cleanup**: cleanup.py script for orphans

## Known Test Patterns

The cleanup system recognizes these patterns:
- `test-`
- `test_`
- `mcp-test`
- `test-mcp`
- `pytest`
- `test-nginx-mcp`
- `test-lifecycle`
- `test-integration`

## Troubleshooting

### Check for Orphaned Resources
```bash
# List all containers on a host
docker -H ssh://user@host ps -a | grep test

# Use cleanup script to find orphans
python tests/cleanup.py --dry-run
```

### Force Cleanup
```bash
# Emergency cleanup - removes ALL test resources
python tests/cleanup.py --emergency

# Clean specific patterns
python tests/cleanup.py --pattern "test-" --host squirts
```

### Debug Cleanup Failures
Check the cleanup report generated by tests:
- Failed cleanups are recorded with error messages
- Session cleanup prints summary after all tests
- cleanup.py generates detailed reports

## Best Practices

1. **Always use try-finally**: Wrap resource deployment in try-finally blocks
2. **Track resources**: Use TestResourceTracker to track all deployed resources
3. **Use finalizers**: Register pytest finalizers for critical cleanup
4. **Test cleanup**: Run cleanup.py --dry-run before committing
5. **Monitor cleanup**: Check session cleanup output after test runs
6. **Name consistently**: Use test- prefix for all test resources

## CI/CD Integration

Add to CI pipeline:
```yaml
- name: Run tests
  run: pytest tests/

- name: Verify cleanup
  run: python tests/cleanup.py --dry-run
  
- name: Emergency cleanup (if needed)
  if: failure()
  run: python tests/cleanup.py --emergency
```

## Configuration

Test resources are deployed to the host specified in `conftest.py`:
```python
@pytest.fixture
def test_host_id() -> str:
    return "squirts"  # Change this to use different test host
```

## Limitations

- Container removal requires "rm" command in allowed Docker commands
- Currently only stops containers, doesn't remove them
- Stack removal depends on compose file presence on remote host
- Cleanup may fail if Docker daemon is unresponsive

## Future Improvements

1. Add "rm" to allowed Docker commands for complete container removal
2. Implement parallel cleanup for faster execution
3. Add cleanup metrics and monitoring
4. Create cleanup dashboard for visibility
5. Implement automatic cleanup scheduling